// Code generated by counterfeiter. DO NOT EDIT.
package outputfakes

import (
	"sync"

	"github.com/vmware-labs/marketplace-cli/v2/cmd/output"
	"github.com/vmware-labs/marketplace-cli/v2/internal/models"
)

type FakeFormat struct {
	RenderChartStub        func(*models.ChartVersion) error
	renderChartMutex       sync.RWMutex
	renderChartArgsForCall []struct {
		arg1 *models.ChartVersion
	}
	renderChartReturns struct {
		result1 error
	}
	renderChartReturnsOnCall map[int]struct {
		result1 error
	}
	RenderChartsStub        func([]*models.ChartVersion) error
	renderChartsMutex       sync.RWMutex
	renderChartsArgsForCall []struct {
		arg1 []*models.ChartVersion
	}
	renderChartsReturns struct {
		result1 error
	}
	renderChartsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderContainerImageStub        func(*models.DockerURLDetails) error
	renderContainerImageMutex       sync.RWMutex
	renderContainerImageArgsForCall []struct {
		arg1 *models.DockerURLDetails
	}
	renderContainerImageReturns struct {
		result1 error
	}
	renderContainerImageReturnsOnCall map[int]struct {
		result1 error
	}
	RenderContainerImagesStub        func(*models.DockerVersionList) error
	renderContainerImagesMutex       sync.RWMutex
	renderContainerImagesArgsForCall []struct {
		arg1 *models.DockerVersionList
	}
	renderContainerImagesReturns struct {
		result1 error
	}
	renderContainerImagesReturnsOnCall map[int]struct {
		result1 error
	}
	RenderOVAStub        func(*models.ProductDeploymentFile) error
	renderOVAMutex       sync.RWMutex
	renderOVAArgsForCall []struct {
		arg1 *models.ProductDeploymentFile
	}
	renderOVAReturns struct {
		result1 error
	}
	renderOVAReturnsOnCall map[int]struct {
		result1 error
	}
	RenderOVAsStub        func([]*models.ProductDeploymentFile) error
	renderOVAsMutex       sync.RWMutex
	renderOVAsArgsForCall []struct {
		arg1 []*models.ProductDeploymentFile
	}
	renderOVAsReturns struct {
		result1 error
	}
	renderOVAsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderProductStub        func(*models.Product) error
	renderProductMutex       sync.RWMutex
	renderProductArgsForCall []struct {
		arg1 *models.Product
	}
	renderProductReturns struct {
		result1 error
	}
	renderProductReturnsOnCall map[int]struct {
		result1 error
	}
	RenderProductsStub        func([]*models.Product) error
	renderProductsMutex       sync.RWMutex
	renderProductsArgsForCall []struct {
		arg1 []*models.Product
	}
	renderProductsReturns struct {
		result1 error
	}
	renderProductsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderVersionStub        func(*models.Product, string) error
	renderVersionMutex       sync.RWMutex
	renderVersionArgsForCall []struct {
		arg1 *models.Product
		arg2 string
	}
	renderVersionReturns struct {
		result1 error
	}
	renderVersionReturnsOnCall map[int]struct {
		result1 error
	}
	RenderVersionsStub        func(*models.Product) error
	renderVersionsMutex       sync.RWMutex
	renderVersionsArgsForCall []struct {
		arg1 *models.Product
	}
	renderVersionsReturns struct {
		result1 error
	}
	renderVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFormat) RenderChart(arg1 *models.ChartVersion) error {
	fake.renderChartMutex.Lock()
	ret, specificReturn := fake.renderChartReturnsOnCall[len(fake.renderChartArgsForCall)]
	fake.renderChartArgsForCall = append(fake.renderChartArgsForCall, struct {
		arg1 *models.ChartVersion
	}{arg1})
	fake.recordInvocation("RenderChart", []interface{}{arg1})
	fake.renderChartMutex.Unlock()
	if fake.RenderChartStub != nil {
		return fake.RenderChartStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderChartReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderChartCallCount() int {
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	return len(fake.renderChartArgsForCall)
}

func (fake *FakeFormat) RenderChartCalls(stub func(*models.ChartVersion) error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = stub
}

func (fake *FakeFormat) RenderChartArgsForCall(i int) *models.ChartVersion {
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	argsForCall := fake.renderChartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderChartReturns(result1 error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = nil
	fake.renderChartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderChartReturnsOnCall(i int, result1 error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = nil
	if fake.renderChartReturnsOnCall == nil {
		fake.renderChartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderChartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderCharts(arg1 []*models.ChartVersion) error {
	var arg1Copy []*models.ChartVersion
	if arg1 != nil {
		arg1Copy = make([]*models.ChartVersion, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderChartsMutex.Lock()
	ret, specificReturn := fake.renderChartsReturnsOnCall[len(fake.renderChartsArgsForCall)]
	fake.renderChartsArgsForCall = append(fake.renderChartsArgsForCall, struct {
		arg1 []*models.ChartVersion
	}{arg1Copy})
	fake.recordInvocation("RenderCharts", []interface{}{arg1Copy})
	fake.renderChartsMutex.Unlock()
	if fake.RenderChartsStub != nil {
		return fake.RenderChartsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderChartsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderChartsCallCount() int {
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	return len(fake.renderChartsArgsForCall)
}

func (fake *FakeFormat) RenderChartsCalls(stub func([]*models.ChartVersion) error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = stub
}

func (fake *FakeFormat) RenderChartsArgsForCall(i int) []*models.ChartVersion {
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	argsForCall := fake.renderChartsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderChartsReturns(result1 error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = nil
	fake.renderChartsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderChartsReturnsOnCall(i int, result1 error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = nil
	if fake.renderChartsReturnsOnCall == nil {
		fake.renderChartsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderChartsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImage(arg1 *models.DockerURLDetails) error {
	fake.renderContainerImageMutex.Lock()
	ret, specificReturn := fake.renderContainerImageReturnsOnCall[len(fake.renderContainerImageArgsForCall)]
	fake.renderContainerImageArgsForCall = append(fake.renderContainerImageArgsForCall, struct {
		arg1 *models.DockerURLDetails
	}{arg1})
	fake.recordInvocation("RenderContainerImage", []interface{}{arg1})
	fake.renderContainerImageMutex.Unlock()
	if fake.RenderContainerImageStub != nil {
		return fake.RenderContainerImageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderContainerImageReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderContainerImageCallCount() int {
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	return len(fake.renderContainerImageArgsForCall)
}

func (fake *FakeFormat) RenderContainerImageCalls(stub func(*models.DockerURLDetails) error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = stub
}

func (fake *FakeFormat) RenderContainerImageArgsForCall(i int) *models.DockerURLDetails {
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	argsForCall := fake.renderContainerImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderContainerImageReturns(result1 error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = nil
	fake.renderContainerImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImageReturnsOnCall(i int, result1 error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = nil
	if fake.renderContainerImageReturnsOnCall == nil {
		fake.renderContainerImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderContainerImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImages(arg1 *models.DockerVersionList) error {
	fake.renderContainerImagesMutex.Lock()
	ret, specificReturn := fake.renderContainerImagesReturnsOnCall[len(fake.renderContainerImagesArgsForCall)]
	fake.renderContainerImagesArgsForCall = append(fake.renderContainerImagesArgsForCall, struct {
		arg1 *models.DockerVersionList
	}{arg1})
	fake.recordInvocation("RenderContainerImages", []interface{}{arg1})
	fake.renderContainerImagesMutex.Unlock()
	if fake.RenderContainerImagesStub != nil {
		return fake.RenderContainerImagesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderContainerImagesReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderContainerImagesCallCount() int {
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	return len(fake.renderContainerImagesArgsForCall)
}

func (fake *FakeFormat) RenderContainerImagesCalls(stub func(*models.DockerVersionList) error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = stub
}

func (fake *FakeFormat) RenderContainerImagesArgsForCall(i int) *models.DockerVersionList {
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	argsForCall := fake.renderContainerImagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderContainerImagesReturns(result1 error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = nil
	fake.renderContainerImagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImagesReturnsOnCall(i int, result1 error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = nil
	if fake.renderContainerImagesReturnsOnCall == nil {
		fake.renderContainerImagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderContainerImagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderOVA(arg1 *models.ProductDeploymentFile) error {
	fake.renderOVAMutex.Lock()
	ret, specificReturn := fake.renderOVAReturnsOnCall[len(fake.renderOVAArgsForCall)]
	fake.renderOVAArgsForCall = append(fake.renderOVAArgsForCall, struct {
		arg1 *models.ProductDeploymentFile
	}{arg1})
	fake.recordInvocation("RenderOVA", []interface{}{arg1})
	fake.renderOVAMutex.Unlock()
	if fake.RenderOVAStub != nil {
		return fake.RenderOVAStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderOVAReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderOVACallCount() int {
	fake.renderOVAMutex.RLock()
	defer fake.renderOVAMutex.RUnlock()
	return len(fake.renderOVAArgsForCall)
}

func (fake *FakeFormat) RenderOVACalls(stub func(*models.ProductDeploymentFile) error) {
	fake.renderOVAMutex.Lock()
	defer fake.renderOVAMutex.Unlock()
	fake.RenderOVAStub = stub
}

func (fake *FakeFormat) RenderOVAArgsForCall(i int) *models.ProductDeploymentFile {
	fake.renderOVAMutex.RLock()
	defer fake.renderOVAMutex.RUnlock()
	argsForCall := fake.renderOVAArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderOVAReturns(result1 error) {
	fake.renderOVAMutex.Lock()
	defer fake.renderOVAMutex.Unlock()
	fake.RenderOVAStub = nil
	fake.renderOVAReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderOVAReturnsOnCall(i int, result1 error) {
	fake.renderOVAMutex.Lock()
	defer fake.renderOVAMutex.Unlock()
	fake.RenderOVAStub = nil
	if fake.renderOVAReturnsOnCall == nil {
		fake.renderOVAReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderOVAReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderOVAs(arg1 []*models.ProductDeploymentFile) error {
	var arg1Copy []*models.ProductDeploymentFile
	if arg1 != nil {
		arg1Copy = make([]*models.ProductDeploymentFile, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderOVAsMutex.Lock()
	ret, specificReturn := fake.renderOVAsReturnsOnCall[len(fake.renderOVAsArgsForCall)]
	fake.renderOVAsArgsForCall = append(fake.renderOVAsArgsForCall, struct {
		arg1 []*models.ProductDeploymentFile
	}{arg1Copy})
	fake.recordInvocation("RenderOVAs", []interface{}{arg1Copy})
	fake.renderOVAsMutex.Unlock()
	if fake.RenderOVAsStub != nil {
		return fake.RenderOVAsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderOVAsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderOVAsCallCount() int {
	fake.renderOVAsMutex.RLock()
	defer fake.renderOVAsMutex.RUnlock()
	return len(fake.renderOVAsArgsForCall)
}

func (fake *FakeFormat) RenderOVAsCalls(stub func([]*models.ProductDeploymentFile) error) {
	fake.renderOVAsMutex.Lock()
	defer fake.renderOVAsMutex.Unlock()
	fake.RenderOVAsStub = stub
}

func (fake *FakeFormat) RenderOVAsArgsForCall(i int) []*models.ProductDeploymentFile {
	fake.renderOVAsMutex.RLock()
	defer fake.renderOVAsMutex.RUnlock()
	argsForCall := fake.renderOVAsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderOVAsReturns(result1 error) {
	fake.renderOVAsMutex.Lock()
	defer fake.renderOVAsMutex.Unlock()
	fake.RenderOVAsStub = nil
	fake.renderOVAsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderOVAsReturnsOnCall(i int, result1 error) {
	fake.renderOVAsMutex.Lock()
	defer fake.renderOVAsMutex.Unlock()
	fake.RenderOVAsStub = nil
	if fake.renderOVAsReturnsOnCall == nil {
		fake.renderOVAsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderOVAsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProduct(arg1 *models.Product) error {
	fake.renderProductMutex.Lock()
	ret, specificReturn := fake.renderProductReturnsOnCall[len(fake.renderProductArgsForCall)]
	fake.renderProductArgsForCall = append(fake.renderProductArgsForCall, struct {
		arg1 *models.Product
	}{arg1})
	fake.recordInvocation("RenderProduct", []interface{}{arg1})
	fake.renderProductMutex.Unlock()
	if fake.RenderProductStub != nil {
		return fake.RenderProductStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderProductReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderProductCallCount() int {
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	return len(fake.renderProductArgsForCall)
}

func (fake *FakeFormat) RenderProductCalls(stub func(*models.Product) error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = stub
}

func (fake *FakeFormat) RenderProductArgsForCall(i int) *models.Product {
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	argsForCall := fake.renderProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderProductReturns(result1 error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = nil
	fake.renderProductReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProductReturnsOnCall(i int, result1 error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = nil
	if fake.renderProductReturnsOnCall == nil {
		fake.renderProductReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderProductReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProducts(arg1 []*models.Product) error {
	var arg1Copy []*models.Product
	if arg1 != nil {
		arg1Copy = make([]*models.Product, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderProductsMutex.Lock()
	ret, specificReturn := fake.renderProductsReturnsOnCall[len(fake.renderProductsArgsForCall)]
	fake.renderProductsArgsForCall = append(fake.renderProductsArgsForCall, struct {
		arg1 []*models.Product
	}{arg1Copy})
	fake.recordInvocation("RenderProducts", []interface{}{arg1Copy})
	fake.renderProductsMutex.Unlock()
	if fake.RenderProductsStub != nil {
		return fake.RenderProductsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderProductsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderProductsCallCount() int {
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	return len(fake.renderProductsArgsForCall)
}

func (fake *FakeFormat) RenderProductsCalls(stub func([]*models.Product) error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = stub
}

func (fake *FakeFormat) RenderProductsArgsForCall(i int) []*models.Product {
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	argsForCall := fake.renderProductsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderProductsReturns(result1 error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = nil
	fake.renderProductsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProductsReturnsOnCall(i int, result1 error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = nil
	if fake.renderProductsReturnsOnCall == nil {
		fake.renderProductsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderProductsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersion(arg1 *models.Product, arg2 string) error {
	fake.renderVersionMutex.Lock()
	ret, specificReturn := fake.renderVersionReturnsOnCall[len(fake.renderVersionArgsForCall)]
	fake.renderVersionArgsForCall = append(fake.renderVersionArgsForCall, struct {
		arg1 *models.Product
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RenderVersion", []interface{}{arg1, arg2})
	fake.renderVersionMutex.Unlock()
	if fake.RenderVersionStub != nil {
		return fake.RenderVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderVersionReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderVersionCallCount() int {
	fake.renderVersionMutex.RLock()
	defer fake.renderVersionMutex.RUnlock()
	return len(fake.renderVersionArgsForCall)
}

func (fake *FakeFormat) RenderVersionCalls(stub func(*models.Product, string) error) {
	fake.renderVersionMutex.Lock()
	defer fake.renderVersionMutex.Unlock()
	fake.RenderVersionStub = stub
}

func (fake *FakeFormat) RenderVersionArgsForCall(i int) (*models.Product, string) {
	fake.renderVersionMutex.RLock()
	defer fake.renderVersionMutex.RUnlock()
	argsForCall := fake.renderVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFormat) RenderVersionReturns(result1 error) {
	fake.renderVersionMutex.Lock()
	defer fake.renderVersionMutex.Unlock()
	fake.RenderVersionStub = nil
	fake.renderVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersionReturnsOnCall(i int, result1 error) {
	fake.renderVersionMutex.Lock()
	defer fake.renderVersionMutex.Unlock()
	fake.RenderVersionStub = nil
	if fake.renderVersionReturnsOnCall == nil {
		fake.renderVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersions(arg1 *models.Product) error {
	fake.renderVersionsMutex.Lock()
	ret, specificReturn := fake.renderVersionsReturnsOnCall[len(fake.renderVersionsArgsForCall)]
	fake.renderVersionsArgsForCall = append(fake.renderVersionsArgsForCall, struct {
		arg1 *models.Product
	}{arg1})
	fake.recordInvocation("RenderVersions", []interface{}{arg1})
	fake.renderVersionsMutex.Unlock()
	if fake.RenderVersionsStub != nil {
		return fake.RenderVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderVersionsCallCount() int {
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	return len(fake.renderVersionsArgsForCall)
}

func (fake *FakeFormat) RenderVersionsCalls(stub func(*models.Product) error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = stub
}

func (fake *FakeFormat) RenderVersionsArgsForCall(i int) *models.Product {
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	argsForCall := fake.renderVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderVersionsReturns(result1 error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = nil
	fake.renderVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersionsReturnsOnCall(i int, result1 error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = nil
	if fake.renderVersionsReturnsOnCall == nil {
		fake.renderVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	fake.renderOVAMutex.RLock()
	defer fake.renderOVAMutex.RUnlock()
	fake.renderOVAsMutex.RLock()
	defer fake.renderOVAsMutex.RUnlock()
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	fake.renderVersionMutex.RLock()
	defer fake.renderVersionMutex.RUnlock()
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFormat) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ output.Format = new(FakeFormat)
